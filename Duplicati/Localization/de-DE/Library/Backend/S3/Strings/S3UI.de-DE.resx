<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BucketnameCaseWarning" xml:space="preserve">
    <value>Der Bucket-Name enthält auch Großbuchstaben.
{0}
Wollen Sie den Bucket-Namen in Kleinbuchstaben umwandeln?</value>
  </data>
  <data name="BucketnameNotPrefixedWarning" xml:space="preserve">
    <value>Der Bucket-Name fängt nicht mit Ihrer UserID an.
Um zu verhindern, dass der Bucket von einem anderen Benutzer übernommen wird, ist es empfehlenswert Ihre UserID am Anfang des Bucket-Namen zu stellen.
Wollen Sie Ihre UserID am Anfang des Bucket-Namens einfügen?</value>
  </data>
  <data name="CreateMissingBucket" xml:space="preserve">
    <value>Das Bucket ist noch nicht vorhanden. Wollen Sie eines erstellen?</value>
  </data>
  <data name="EmptyAWSIDError" xml:space="preserve">
    <value>Sie müssen Ihre AWS Access-ID eingeben. Sie können auf den Link rechts  klicken, um die AWS Login-Seite zu öffnen und die Eingabe erneut vorzunehmen.</value>
  </data>
  <data name="EmptyAWSKeyError" xml:space="preserve">
    <value>Sie müssen Ihren AWS Secret Key eingeben. Sie können auf den Link rechts  klicken, um die AWS Login-Seite zu öffnen und die Eingabe erneut vorzunehmen.</value>
  </data>
  <data name="EmptyBucketnameError" xml:space="preserve">
    <value>Sie müssen einen Namen für das Bucket eingeben. Sie müssen einen eindeutigen Namen für jedes Backup verwenden. Sie können einen beliebigen Namen angeben, der Ihnen gefällt.</value>
  </data>
  <data name="HostnameInvalidWarning" xml:space="preserve">
    <value>Der angegebene Bucket Name, "{0}", scheint kein gültiges Hostnamens-Label zu sein. Dies kann trotzdem funktionieren, wenn der "non-subdomain calling" Stil verwendet wird, aber es wird nicht empfohlen. Wollen Sie trotzdem fortfahren?</value>
  </data>
  <data name="HostnameInvalidWithNonUSBucketOptionError" xml:space="preserve">
    <value>Nicht-US-S3-Buckets setzen voraus, dass die Bucket-Namen gültige Hostname-Labels sind, der vorgeshene S3-Bucket-Name "{0}" ist jedoch kein gültiges Hostname-Label. Ändern Sie entweder den Bucket-Namen oder verwenden Sie die Standard-S3-Bucket-Region.</value>
  </data>
  <data name="MonoRequiresExistingBucket" xml:space="preserve">
    <value>Ein Fehler in Mono-Versionen älter als 2.4.3 verhindert, dass das Backend die fehlenden Buckets erkennt.
Deshalb ist wird empfpohlen, dass Sie ein Bucket erstellen.
Wollen Sie jetzt ein Bucket erstellen?</value>
  </data>
  <data name="NewS3RequiresLowerCaseError" xml:space="preserve">
    <value>Die neue S3-Programmierschnittstelle verlangt für Bucket-Namen Kleinbuchstaben.</value>
  </data>
  <data name="NonUSBucketsRequireLowerCaseError" xml:space="preserve">
    <value>Nicht-US-Buckets setzen voraus, dass der S3-Bucket-Name in Kleinbuchstaben geschrieben wird.</value>
  </data>
  <data name="PageDescription" xml:space="preserve">
    <value>Auf dieser Seite können Sie wählen, wo die Sicherungsdateien angelegt werden sollen.</value>
  </data>
  <data name="PageTitle" xml:space="preserve">
    <value>Optionen für das Sicherungsziel</value>
  </data>
</root>