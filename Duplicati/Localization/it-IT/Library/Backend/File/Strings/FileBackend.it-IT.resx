<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AlternateDestinationMarkerLong" xml:space="preserve">
    <value>Questa opzione funziona solo quando anche la seguente opzione viene specificate --{0}. Se ci sono percorsi alternativi specificati, questa opzione indica il nome di un indicatore che deve essere presente nella cartella. Questo può essere usato per gestire situazioni in cui un drive o disco esterno cambia lettera o punto di mountaggio. Facendo in modo che un certo file esista, è possibile impedire la scrittura accidentale di dati sul disco esterno sbagliato. I contenuti del file non sono mai esaminati, lo sarà solo l'esistenza del file.</value>
  </data>
  <data name="AlternateDestinationMarkerShort" xml:space="preserve">
    <value>Cercare un file nella cartella di destinazione</value>
  </data>
  <data name="AlternateTargetPathsLong" xml:space="preserve">
    <value>Questa opzione permette di specificare destinazioni multiple. Il percorso della destinazione primaria è posizionato prima dell'elenco dei percorsi in dotazione con questa opzione. Prima di iniziare il backup, ogni cartella presente nella lista viene controllata per verificarne l'esistenza e verificare eventualmente anche la presenza del marcatore fornito da --{0}. Il primo percorso esistente, che contiene opzionalmente il file marcatore, verrà quindi utilizzato come destinazione. Più destinazioni sono separate da una {1},. Su Windows, il percorso potrebbe essere un percorso UNC, e la lettera di unità potrebbe essere sostituita da un asterisco (*), ad es. "*:\Backup" esaminerà tutte le lettere di unità. Se un nome utente e una password vengono forniti, le stesse credenziali verranno utilizzate per tutte le destinazioni.</value>
  </data>
  <data name="AlternateTargetPathsShort" xml:space="preserve">
    <value>Elenco di percorsi di destinazione secondari</value>
  </data>
  <data name="Description" xml:space="preserve">
    <value>Questo backend può leggere e scrivere dati verso un backend basato su file. I formati ammessi sono "file://hostname/cartella" o "file://nomeutente:password@hostname/cartella". Si possono fornire dei percorsi UNC (ad esempio: "file://\\server\cartella") o percorsi locali (ad esempio: (win) "file://c:\cartella", (linux) "file:///usr/pub/files")</value>
  </data>
  <data name="DescriptionFTPPasswordLong" xml:space="preserve">
    <value>Password utilizzata per connettersi al server. Essa può anche essere fornita come variabile d'ambiente "FTP_PASSWORD".</value>
  </data>
  <data name="DescriptionFTPPasswordShort" xml:space="preserve">
    <value>Fornire la password utilizzata per la connessione al server</value>
  </data>
  <data name="DescriptionFTPUsernameLong" xml:space="preserve">
    <value>Il nome utente utilizzato per connettersi al server. Esso può anche essere fornito come variabile d'ambiente "FTP_USERNAME".</value>
  </data>
  <data name="DescriptionFTPUsernameShort" xml:space="preserve">
    <value>Fornire il nome utente utilizzato per la connessione al server</value>
  </data>
  <data name="DisplayName" xml:space="preserve">
    <value>Basato su file</value>
  </data>
  <data name="FolderMissingError" xml:space="preserve">
    <value>La cartella {0} non esiste</value>
  </data>
  <data name="NoDestinationWithMarkerFileError" xml:space="preserve">
    <value>Il file marcatore "{0}" non è stato trovato in una delle destinazioni in esame: {1}</value>
  </data>
  <data name="UseMoveForPutLong" xml:space="preserve">
    <value>Quando si archivia il file il funzionamento standard è quello di copiare il file e cancellare l'originale. Questa sequenza assicura che l'operazione può essere ripetuta se qualcosa va storto. L'attivazione di questa opzione può causare la reiterazione dell'operazione fallita. Questa opzione non ha alcun effetto a meno che l'opzione --disable-streaming-transfers non sia attivata.</value>
  </data>
  <data name="UseMoveForPutShort" xml:space="preserve">
    <value>Spostare il file invece di copiarlo</value>
  </data>
</root>