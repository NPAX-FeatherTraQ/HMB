<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BackendNotFoundError" xml:space="preserve">
    <value>无法找到后台: {0}</value>
  </data>
  <data name="FileDeleteError2" xml:space="preserve">
    <value>删除文件失败 "{0}": {1}</value>
  </data>
  <data name="FileDownloadError2" xml:space="preserve">
    <value>下载文件失败 "{0}": {1}</value>
  </data>
  <data name="FileListingError" xml:space="preserve">
    <value>获得文件列表失败: {0}</value>
  </data>
  <data name="FilenameParseError" xml:space="preserve">
    <value>在卷中无法解析文件名</value>
  </data>
  <data name="FilesNotForceRemovedMessage" xml:space="preserve">
    <value>没有文件被删除，请使用—force选项来删除文件。</value>
  </data>
  <data name="FileUploadError2" xml:space="preserve">
    <value>上传文件失败 "{0}": {1}</value>
  </data>
  <data name="FunctionLookupError" xml:space="preserve">
    <value>无法找到函数: {0}</value>
  </data>
  <data name="HashMismatchError" xml:space="preserve">
    <value>文件 "{0}"的哈希码不匹配，记录的哈希码是: {1}, 实际的哈希码是：{2}</value>
  </data>
  <data name="InvalidEntryTypeError" xml:space="preserve">
    <value>无效的条目类型: {0}</value>
  </data>
  <data name="NoBackupsFoundError" xml:space="preserve">
    <value>在远端没有发现备份</value>
  </data>
  <data name="OrphanIncrementalFoundMessage" xml:space="preserve">
    <value>由增量包恢复完整备份时失败: {0}</value>
  </data>
  <data name="PartialFileFoundMessage" xml:space="preserve">
    <value>发现一个破损文件，请运行清空操作来删除 {0}</value>
  </data>
  <data name="RemovingLeftoverFileMessage" xml:space="preserve">
    <value>删除残留文件: {0}</value>
  </data>
  <data name="StatusMessageDownloading" xml:space="preserve">
    <value>下载中: {0}</value>
  </data>
  <data name="StatusMessageUploading" xml:space="preserve">
    <value>上传中: {0} ({1})</value>
  </data>
  <data name="DuplicateFileEntryWarning" xml:space="preserve">
    <value>文件{0} 已经在文件列表中发现了多次，这很有可能是后台的一个错误，请将此问题报告给开发者</value>
  </data>
  <data name="EmptyManifestWarning" xml:space="preserve">
    <value>发现了空的备份集合，这很有可能是一个错误: {0}</value>
  </data>
  <data name="RemoveOrphanFileWarning" xml:space="preserve">
    <value>删除孤立文件: {0}</value>
  </data>
  <data name="UnmatchedFilenameWarning" xml:space="preserve">
    <value>后台中发现了文件{0}，但是Duplicati无法识别这个文件</value>
  </data>
  <data name="CachedSignatureHashMismatchWarning" xml:space="preserve">
    <value>缓存文件{0}的哈希码与原始文件不相符，忽略缓存文件</value>
  </data>
  <data name="DeleteCacheFileError" xml:space="preserve">
    <value>尝试删除缓存文件 {0}时出错</value>
  </data>
  <data name="SaveCacheFileError" xml:space="preserve">
    <value>无法将缓存的签名保存为 {0}</value>
  </data>
  <data name="BackendDoesNotSupportCreateFolder" xml:space="preserve">
    <value>后台 {0} ({1})不支持 CreateFolder 操作 </value>
  </data>
  <data name="CachedSignatureDecryptWarning" xml:space="preserve">
    <value>尝试解密文件 {0}失败，错误: {1}</value>
  </data>
  <data name="TooManyOrphansFoundError" xml:space="preserve">
    <value>已经指定了自动清空操作，但是只有{0}个 孤立文件，至少应该有多余2个。</value>
  </data>
  <data name="UploadSizeVerificationFailure" xml:space="preserve">
    <value>文件 {0} 已经上传到了服务器上，报告的文件大小是 {1} ，预期的大小应该是{2}</value>
  </data>
  <data name="UploadVerificationFailure" xml:space="preserve">
    <value>文件 {0} 已经上传，但是没有在服务器上找到</value>
  </data>
  <data name="FailureWhileDisposingBackendError" xml:space="preserve">
    <value>关闭连接错误： {0}</value>
  </data>
  <data name="DownloadedFileSizeError" xml:space="preserve">
    <value>文件{0} 已经下载，大小是 {1} ，但是预期的文件大小是 {2}</value>
  </data>
  <data name="CompletedDeleteTransaction" xml:space="preserve">
    <value>删除操作成功</value>
  </data>
  <data name="CompletingDeleteTransactionWarning" xml:space="preserve">
    <value>完成未完成的删除操作，删除了 {0} 个文件</value>
  </data>
  <data name="DeleteTransactionFileFoundWarning" xml:space="preserve">
    <value>一个删除操作已经开始，但是没有完成。下一次调用清空或者删除命令时将会完成此次删除。</value>
  </data>
  <data name="DeleteTransactionFileReadError" xml:space="preserve">
    <value>一个之前的删除操作没有完成，尝试恢复操作时出错: {1}.

如果这个错误发生了多次，那么有可能删除文件操作本身有问题。尝试重命名文件 "{0}" ，然后再运行该操作。如果没有错误发生，那么可以安全删除这个文件，否则Duplicati将会报告如何手工纠正这个问题。</value>
  </data>
  <data name="DeletingTransactionLeftoverFile" xml:space="preserve">
    <value>从删除操作 "{0}"中删除文件</value>
  </data>
  <data name="ExistingDeleteTransactionError" xml:space="preserve">
    <value>发生了一个内部错误，有一个发起删除操作的请求，但是已经有一个操作存在</value>
  </data>
  <data name="MultipleDeleteTransactionsFoundError" xml:space="preserve">
    <value>发现了多个删除操作文件。请手工检查目标地址，然后解决此问题。</value>
  </data>
  <data name="NonExistingDeleteTransactionError" xml:space="preserve">
    <value>发生了一个内部错误，有一个完成删除操作的请求，但是进程中没有任何操作</value>
  </data>
  <data name="AutoCreateFolderFailed" xml:space="preserve">
    <value>Failed to automatically create folder, error message: {0}</value>
  </data>
</root>