<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="BackendNotFoundError" xml:space="preserve">
    <value>Не найден модуль для: {0}</value>
  </data>
  <data name="FileDeleteError2" xml:space="preserve">
    <value>Не удалить файл "{0}": {1}</value>
  </data>
  <data name="FileDownloadError2" xml:space="preserve">
    <value>Невозможно скачать файл "{0}": {1}</value>
  </data>
  <data name="FileListingError" xml:space="preserve">
    <value>Не удается получить список файлов: {0}</value>
  </data>
  <data name="FilenameParseError" xml:space="preserve">
    <value>Не распознать имена файлов для указанных томов</value>
  </data>
  <data name="FilesNotForceRemovedMessage" xml:space="preserve">
    <value>Файлы не удалялись, укажите --force, чтобы удалить их.</value>
  </data>
  <data name="FileUploadError2" xml:space="preserve">
    <value>Не удалось передать файл "{0}": {1}</value>
  </data>
  <data name="FunctionLookupError" xml:space="preserve">
    <value>Не удалось найти функцию: {0}</value>
  </data>
  <data name="HashMismatchError" xml:space="preserve">
    <value>Несовпадение контрольной суммы файла "{0}", записано: {1}, фактически {2}</value>
  </data>
  <data name="InvalidEntryTypeError" xml:space="preserve">
    <value>Недопустимый тип записи: {0}</value>
  </data>
  <data name="NoBackupsFoundError" xml:space="preserve">
    <value>В хранилище копии не найдены</value>
  </data>
  <data name="OrphanIncrementalFoundMessage" xml:space="preserve">
    <value>Не удается сопоставить инкрементальную копию с полной: {0}</value>
  </data>
  <data name="PartialFileFoundMessage" xml:space="preserve">
    <value>Найдена часть файла, запустите очистку для удаления: {0}</value>
  </data>
  <data name="RemovingLeftoverFileMessage" xml:space="preserve">
    <value>Удаление оставшегося файла: {0}</value>
  </data>
  <data name="StatusMessageDownloading" xml:space="preserve">
    <value>Загрузка: {0}</value>
  </data>
  <data name="StatusMessageUploading" xml:space="preserve">
    <value>Передача: {0} ({1})</value>
  </data>
  <data name="DuplicateFileEntryWarning" xml:space="preserve">
    <value>Файл {0} повторяется в списке, похоже на ошибку модуля работы с хранилищем, сообщите о ней разработчикам</value>
  </data>
  <data name="EmptyManifestWarning" xml:space="preserve">
    <value>Обнаружены пустые копии, это похоже на ошибку: {0}</value>
  </data>
  <data name="RemoveOrphanFileWarning" xml:space="preserve">
    <value>Удаление файлов неясной принадлежности: {0}</value>
  </data>
  <data name="UnmatchedFilenameWarning" xml:space="preserve">
    <value>Файл {0} найден в хранилище, но программа его не может распознать</value>
  </data>
  <data name="CachedSignatureHashMismatchWarning" xml:space="preserve">
    <value>Файл кэша {0} не соответствует контрольной сумме, игнорируем его</value>
  </data>
  <data name="DeleteCacheFileError" xml:space="preserve">
    <value>Ошибка при удалении файла кэша {0}</value>
  </data>
  <data name="SaveCacheFileError" xml:space="preserve">
    <value>Не вышло записать закэшированный файл подписи как {0}</value>
  </data>
  <data name="BackendDoesNotSupportCreateFolder" xml:space="preserve">
    <value>Модуль {0} ({1}) не поддерживает операцию создания папки</value>
  </data>
  <data name="CachedSignatureDecryptWarning" xml:space="preserve">
    <value>Попытка расшифровать файл {0} завершилась ошибкой: {1}</value>
  </data>
  <data name="TooManyOrphansFoundError" xml:space="preserve">
    <value>Установлена автоочистка, обнаружено {0} потерянных файлов, а должно быть не более 2</value>
  </data>
  <data name="UploadSizeVerificationFailure" xml:space="preserve">
    <value>Файл {0} был передан на сервер, его размер на сервере {1} а должен быть {2}</value>
  </data>
  <data name="UploadVerificationFailure" xml:space="preserve">
    <value>Файл {0} был передан на сервер, но не появился там</value>
  </data>
  <data name="FailureWhileDisposingBackendError" xml:space="preserve">
    <value>Ошибка при завершении соединения: {0}</value>
  </data>
  <data name="DownloadedFileSizeError" xml:space="preserve">
    <value>Файл {0} был загружен. Его размер {1}, а должен быть {2}</value>
  </data>
  <data name="CompletedDeleteTransaction" xml:space="preserve">
    <value>Удаление успешно завершено</value>
  </data>
  <data name="CompletingDeleteTransactionWarning" xml:space="preserve">
    <value>Завершение незаконченного удаления и стирание {0} файлов</value>
  </data>
  <data name="DeleteTransactionFileFoundWarning" xml:space="preserve">
    <value>Удаление началось, но оно не завершилось. Следующий запуск очистки или удаления завершит операцию.</value>
  </data>
  <data name="DeleteTransactionFileReadError" xml:space="preserve">
    <value>Предыдущее удаление не было завершено, попытка завершения провалилась, ошибка: {1}.

Если ошибка повторяется более одного раза, возможно, файл описания операции дефектный. Попробуйте переименовать файл "{0}" и запустить удаление снова. Если ошибок не будет, удалите переименованный файл, в ином случае программа сообщит, что делать дальше.</value>
  </data>
  <data name="DeletingTransactionLeftoverFile" xml:space="preserve">
    <value>Удаление файла из операции удаления "{0}"</value>
  </data>
  <data name="ExistingDeleteTransactionError" xml:space="preserve">
    <value>Случилась внутренняя ошибка: повторный запрос удаления.</value>
  </data>
  <data name="MultipleDeleteTransactionsFoundError" xml:space="preserve">
    <value>Найдено несколько одновременных запросов на удаление. Проверьте, что именно надо удалить и исправьте эту ошибку.</value>
  </data>
  <data name="NonExistingDeleteTransactionError" xml:space="preserve">
    <value>Внутренняя ошибка: принят запрос на завершение удаления, а удаление не было запрошено ранее</value>
  </data>
  <data name="AutoCreateFolderFailed" xml:space="preserve">
    <value>Сбой автоматического создания папки: {0}</value>
  </data>
  <data name="UnmatchedEncryptionModuleWarning" space="preserve">
    <value>Файл "{0}" имеет модуль шифрования "{1}", он не поддерживается, игнорируем файл</value>
  </data>
  <data name="UnmatchedCompressionModuleWarning" space="preserve">
    <value>Файл "{0}" имеет модуль сжатия "{1}", он не поддерживается, игнориуем файл</value>
  </data>
</root>